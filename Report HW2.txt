Working with I/O
Reading in the input from the file(s) and creating a linked list from that was a relatively straightforward process: in linear time, read a line, pass it through the parseInt function (which takes a string and converts it to a signed integer with that value), and place it in the right location within the list. Once there was no more content to be read, the method returned a pointer to the beginning of that list. Because this is done for every element of the input, and only once for each of those, the I/O part of the algorithm is linear. 

Calculating the Sum and Count
These methods look almost identical to one another. Both are recursive and run in linear time. In both cases, the operation the method does is of the form “add the current value to the value you get when you recursively call the same function with the next element along the list.” In the case of the counter—the denominator when calculating the average—that looks like saying that the length of the list is 1 plus the length of the rest of the list; and in the case of the sum—the numerator—that looks like saying that the total sum is the current value of the node plus the sum of the values of the rest of the list, giving to both the condition that the value of an empty list is 0. These methods recursively go through the entire collection element by element, and no particular element is visited several times, so both methods operate in linear time. 
Calculating the Average 
Calculating the average is not hard once the sum and the count are known. The method for calculating the average simply relies on those two prior calculations, their results stored in class variables rather than local ones, and divides one result by the other. The average calculation—a linear process—is done once; the count calculation—also linear—is done once. Therefore, since the calculation of the average is a non-repeated sequence of a known number of linear steps, it too is a linear process. 
Finding the Average in the Collection
Not being allowed to use a more well-developed form of a list data structure—such as the ArrayList or LinkedList libraries— and being forbidden from changing the list once it has been created means we do not have access to Collections.sort or some other easy method of sorting its contents. Therefore, we have lost access to the most efficient searching methods, like binary search, which operates in logarithmic time by strategically choosing (or ignoring, depending on your perspective) half of a data set at a time to find a data point very quickly in a sorted collection. The most efficient way to find anything, then, becomes simply to do a linear search, checking each element to see if a match has been found. There are both iterative and recursive ways to implement this algorithm, and the recursive option was chosen here: check if the current element is a match, and if not, linearly search the rest of the list. 

Generating a “Yes” or “No” Result
A note regarding the handling of some interesting cases: both the sum and the count are integers, and the result of their division must also be an integer, the way the algorithm has been written. Any correct combination of sums and counts that produces an average that truncates to a number that is in the list is considered a Pass. It should be reinforced here that the operation being done here is truncation rather than rounding, since, half the time, they produce different results. Rounding takes a floating-point number to the integer to which it is closest, either up or down. Truncation, on the other hand, always goes down, since the operation simply ignores whatever value follows the decimal point, even if going up would be a much shorter distance to the next integer. 
The main method makes only one call on one instance of one object from one argument. It creates a new Average object, and that object's methods work on a file specified by main()’s arguments. The object then calculates the average of that list, and checks if the list contains its average. An empty file is defined not to have its average in itself. 

